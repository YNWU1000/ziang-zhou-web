  <!-- enjoy! created by Ziang Zhou/YNWU -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GR1D - Ziang Zhou</title>

  <!-- libs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
<script src="https://unpkg.com/p5.js-svg@1.5.1/lib/p5.svg.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      font-family: "JetBrains Mono", monospace;
      background: #ebebeb;
      color: #646464;
    }
    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: auto;
      z-index: 1;
      background: white;
    }
    #control-panel {
      display: flex;
      flex-direction: column;
      position: absolute;
      top: 0;
      right: 0;
      width: 240px;
      height: 100%;
      background: #ebebeb;
      padding: 20px 15px 20px 15px;
      box-sizing: border-box;
      z-index: 10;
      overflow-y: auto;
    }
    .section { margin-bottom: 40px; }
    .section-title {
      font-size: 12px; color: #000; font-weight: 600; margin-bottom: 20px; letter-spacing: 0.5px;
    }
    .param-group { margin-bottom: 8px; }
    .param-label {
      font-size: 10px; color: #646464; margin-bottom: 5px; display: block;
      text-transform: uppercase; letter-spacing: 0.5px;
    }
    .param-row { display: flex; align-items: center; gap: 8px; }
    .param-value {
      min-width: 32px; background: white; border: 1px solid #ddd; color: #000;
      font-family: "JetBrains Mono", monospace; font-size: 10px; text-align: center;
      padding: 4px 6px; font-weight: 600;
    }
    input[type="range"] { flex: 1; appearance: none; height: 3px; background: #ddd; outline: none; border-radius: 0; }
    input[type="range"]::-webkit-slider-thumb { appearance: none; width: 12px; height: 12px; background: #000; cursor: pointer; border-radius: 0; }
    input[type="range"]::-moz-range-thumb { width: 12px; height: 12px; background: #000; cursor: pointer; border: none; border-radius: 0; }
    select {
      width: 100%; background: white; border: 1px solid #ddd; color: #000;
      font-family: "JetBrains Mono", monospace; font-size: 10px; padding: 6px 8px; font-weight: 600;
      appearance: none;
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23646464' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
      background-position: right 8px center; background-repeat: no-repeat; background-size: 16px; padding-right: 32px;
    }
    .button-group { display: flex; flex-direction: column; gap: 2px; }
    button {
      width: 100%; padding: 8px 12px; border: none; background: white; color: #646464;
      font-family: "JetBrains Mono", monospace; font-size: 10px; font-weight: 600;
      text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; transition: all 0.15s ease;
      position: relative; text-align: left;
    }
    button:hover { background: #d0e1ff; color: #000; }
    button:active { background: #aacdfff0; color: #000; }
    button.active { background: #0000ff; color: white; }
    button.active:hover { background: #0000cc; }
    button::after {
      content: attr(data-shortcut);
      position: absolute; right: 12px; top: 50%; transform: translateY(-50%);
      font-size: 9px; opacity: 0.6;
    }
    .checkbox-row { display: flex; align-items: center; gap: 8px; margin: 15px 0; padding: 6px 0; }
    input[type="checkbox"] {
      appearance: none; width: 12px; height: 12px; border: 1px solid #ddd; background: white; position: relative; cursor: pointer;
    }
    input[type="checkbox"]:checked { background: #000; border-color: #000; }
    input[type="checkbox"]:checked::after {
      content: '✓'; position: absolute; top: -2px; left: 1px; color: white; font-size: 10px; font-weight: bold;
    }
    .checkbox-label { font-size: 10px; color: #646464; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; }
    .special-button { background: #000 !important; color: white !important; text-align: center; position: relative; overflow: hidden; }
    .special-button:hover { background: #333 !important; }
    #clear { margin-top: 4px; margin-bottom: 10px; }
    .param-group.preset-group { margin-top: 20px; margin-bottom: 5px; }
    .preset-buttons { display: flex; gap: 6px; }
    .preset-btn {
      flex: 1; font-size: 10px; padding: 4px 0; font-family: "JetBrains Mono", monospace;
      background: white; text-align: center; color: #646464; border: 1px solid #ddd; cursor: pointer; transition: all 0.05s ease;
    }
    .preset-btn:hover { background: #b9b9b9; color: #000; }
    .preset-btn.active { background: #000; color: white; border-color: #000; }
    .shape-buttons { display: flex; gap: 6px; margin-bottom: 15px; }
    .shape-btn {
      flex: 1; font-size: 10px; padding: 8px 0; font-family: "JetBrains Mono", monospace;
      background: white; text-align: center; color: #646464; border: 1px solid #ddd; cursor: pointer; transition: all 0.05s ease;
    }
    .shape-btn:hover { background: #d0e1ff; color: #000; }
    .shape-btn.active { background: #0000ff; color: white; border-color: #0000ff; }
    .credit { font-family: "Inter", sans-serif; margin-top: 20px; font-size: 11px; color: #888888; text-align: right; width: 100%; }
  </style>
</head>
<body>
  <div id="control-panel">
    <div class="section">
      <div class="section-title">FUNC</div>
      <div class="button-group">
        <button id="undo" data-shortcut="Z">UNDO</button>
        <button id="clear" data-shortcut="X">CLEAR</button>
        <button id="toggleWarp" data-shortcut="W">WARP</button>
        <button id="toggleColor" data-shortcut="C">COLOR</button>
        <button id="toggleOutline" data-shortcut="O">OUTLINE</button>
        <button id="toggleGrid" class="active" data-shortcut="G">SHOW GRID</button>
      </div>
    </div>

    <div class="section">
      <div class="section-title">BRUSH</div>
      <div class="param-group">
        <label class="param-label">Shape</label>
        <div class="shape-buttons">
          <button class="shape-btn active" data-shape="circle">●</button>
          <button class="shape-btn" data-shape="square">■</button>
        </div>
      </div>
      <div class="checkbox-row" id="square-connector-row" style="display:none;">
        <input type="checkbox" id="corner-connect" />
        <label class="checkbox-label" for="corner-connect">UNISON LINE WEIGHT</label>
      </div>
    </div>

    <div class="section">
      <div class="section-title">GRID</div>
<div class="param-group">
        <label class="param-label">Radius</label>
        <div class="param-row">
          <input type="range" id="radius" min="4" max="100" value="56">
          <div class="param-value" id="radius-val">56</div>
        </div>
      </div>

      <div class="param-group">
        <label class="param-label">Spacing</label>
        <div class="param-row">
          <input type="range" id="spacing" min="10" max="200" value="120">
          <div class="param-value" id="spacing-val">120</div>
        </div>
      </div>

      <div class="param-group">
        <label class="param-label">Margin</label>
        <div class="param-row">
          <input type="range" id="margin" min="0" max="300" value="100">
          <div class="param-value" id="margin-val">100</div>
        </div>
      </div>

      <div class="param-group">
        <label class="param-label">Cols</label>
        <div class="param-row">
          <input type="range" id="cols" min="3" max="12" value="6">
          <div class="param-value" id="cols-val">6</div>
        </div>
      </div>

      <div class="param-group">
        <label class="param-label">Rows</label>
        <div class="param-row">
          <input type="range" id="rows" min="3" max="12" value="6">
          <div class="param-value" id="rows-val">6</div>
        </div>
      </div>

      <div class="param-group preset-group">
        <label class="param-label">PRESET</label>
        <div class="preset-buttons">
          <button class="preset-btn" data-preset="3x3">3</button>
          <button class="preset-btn" data-preset="4x4">4</button>
          <button class="preset-btn" data-preset="5x5">5</button>
          <button class="preset-btn active" data-preset="6x6">6</button>
          <button class="preset-btn" data-preset="10x10">10</button>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title">EXPORT</div>
      <div class="param-group">
        <label class="param-label">Size</label>
        <select id="export-size">
          <option value="16">16×16</option>
          <option value="24" selected>24×24</option>
          <option value="32">32×32</option>
          <option value="48">48×48</option>
          <option value="64">64×64</option>
          <option value="128">128×128</option>
          <option value="256">256×256</option>
          <option value="512">512×512</option>
        </select>
      </div>
      <div class="checkbox-row">
        <input type="checkbox" id="mode-toggle" />
        <label class="checkbox-label" for="mode-toggle">Export as lines</label>
      </div>
      <div class="button-group">
        <button id="export-png" class="special-button" data-shortcut="P">Export PNG</button>
        <button id="export-svg" class="special-button" data-shortcut="V">Export SVG</button>
      </div>
    </div>

    <div class="section">
      <div class="section-title">EXPERIMENTAL</div>
      <div class="button-group">
        <button id="surprise" data-shortcut="S">SURPRISE ME</button>
        <button id="toggleGameOfLife" data-shortcut="L">GAME OF LIFE</button>
      </div>
      <div id="game-of-life-controls" style="display:none; margin-top:10px;">
        <div class="param-group">
          <label class="param-label">Speed</label>
          <div class="param-row">
            <input type="range" id="gol-speed" min="1" max="30" value="10">
            <div class="param-value" id="gol-speed-val">10</div>
          </div>
        </div>
        <div class="button-group" style="margin-top:10px;">
          <button id="gol-play" style="background:#4CAF50; color:white;">PLAY</button>
          <button id="gol-step">STEP</button>
          <button id="gol-clear">CLEAR CELLS</button>
        </div>
      </div>
    </div>

    <div class="credit">৻( •̀ ᗜ •́ ৻) ✧</div>
  </div>

  <script>
    // ---------------------------
    // Globals
    // ---------------------------
    let cols = 6, rows = 6, radius = 24, spacing = 60, margin = 50;
    let grid = [];
    let strokes = [];
    let strokeColors = [];
    let strokeShapes = []; // per-stroke shape
    let currentStroke = [];
    let undoStack = [];

    let useColors = false;
    let outlineOnly = false;
    let showGrid = true;
    let brushShape = 'circle';
    let squareConnectorMode = 'corner'; // 'corner' | 'center'

    // Warp
    let warpMode = false;
    let warpStartPoint = null;

    // Game of Life
    let gameOfLifeMode = false;
    let gameOfLifeRunning = false;
    let gameOfLifeGrid = [];
    let gameOfLifeSpeed = 10;
    let frameCounter = 0;

    // ---------------------------
    // Setup / Draw
    // ---------------------------
    function setup() {
      const canvas = createCanvas(window.innerWidth - 240, window.innerHeight);
      canvas.parent(document.body);
      canvas.style('z-index', '1');
      updateValues(); // will rebuild grid
      setupParamUpdates();
      setupShapeButtons();
    }

    function windowResized() {
      resizeCanvas(window.innerWidth - 240, window.innerHeight);
    }

    function draw() {
      background(250);

      if (showGrid && !gameOfLifeMode) {
        stroke(200); strokeWeight(1); noFill();
        for (let i=0;i<cols;i++) for (let j=0;j<rows;j++) {
          if (brushShape === 'square') {
            rectMode(CENTER);
            rect(grid[i][j].x, grid[i][j].y, radius*2, radius*2);
          } else {
            ellipse(grid[i][j].x, grid[i][j].y, radius*2);
          }
        }
      }

      if (gameOfLifeMode) {
        stroke(200); strokeWeight(1); noFill();
        for (let i=0;i<cols;i++) for (let j=0;j<rows;j++) {
          rectMode(CENTER);
          rect(grid[i][j].x, grid[i][j].y, radius*2, radius*2);
        }
        fill(useColors ? color(random(30,220), random(30,220), random(30,220)) : 0);
        noStroke();
        for (let i=0;i<cols;i++) for (let j=0;j<rows;j++) {
          if (gameOfLifeGrid[i] && gameOfLifeGrid[i][j]) {
            rectMode(CENTER);
            rect(grid[i][j].x, grid[i][j].y, radius*2, radius*2);
          }
        }
        if (gameOfLifeRunning) {
          frameCounter++;
          if (frameCounter >= gameOfLifeSpeed) {
            updateGameOfLife();
            frameCounter = 0;
          }
        }
      } else {
        if (warpMode && warpStartPoint) {
          fill(0,0,255,100); noStroke();
          ellipse(warpStartPoint.x, warpStartPoint.y, radius*2.5);
        }
        // Strokes
        for (let i=0;i<strokes.length;i++) {
          drawStrokeOn(window, strokes[i], useColors ? strokeColors[i] : color(0), strokeShapes[i] || 'circle', radius);
        }
        // Current
        drawStrokeOn(window, currentStroke, color(100,100,100,150), brushShape, radius);
      }
    }

    // ---------------------------
    // Drawing Helpers (allow drawing on any p5 graphics context)
    // ---------------------------
    function drawStrokeOn(gfx, strokePath, col, shape, r) {
      if (!strokePath || strokePath.length === 0) return;
      if (outlineOnly) { gfx.stroke(col); gfx.strokeWeight(1); gfx.noFill(); }
      else { gfx.fill(col); gfx.noStroke(); }
      for (let i=0;i<strokePath.length;i++) {
        const p = strokePath[i];
        drawShapeOn(gfx, p.x, p.y, r, shape);
        if (i>0) {
          if (shape === 'circle') drawCapsuleOn(gfx, strokePath[i-1], strokePath[i], r);
          else drawConnectorOn(gfx, strokePath[i-1], strokePath[i], r, shape);
        }
      }
    }
    function drawShapeOn(gfx, x,y,r, shape) {
      gfx.push(); gfx.translate(x,y);
      if (shape === 'square') { gfx.rectMode(CENTER); gfx.rect(0,0,r*2,r*2); }
      else { gfx.ellipse(0,0,r*2); }
      gfx.pop();
    }
    function drawCapsuleOn(gfx, a,b,r) {
      const dir = p5.Vector.sub(b,a).normalize();
      const perp = createVector(-dir.y, dir.x).mult(r);
      const a1 = p5.Vector.add(a, perp);
      const a2 = p5.Vector.sub(a, perp);
      const b1 = p5.Vector.add(b, perp);
      const b2 = p5.Vector.sub(b, perp);
      gfx.beginShape();
      gfx.vertex(a1.x,a1.y); gfx.vertex(b1.x,b1.y);
      gfx.vertex(b2.x,b2.y); gfx.vertex(a2.x,a2.y);
      gfx.endShape(CLOSE);
    }
    function drawConnectorOn(gfx, a,b,r,shape) {
      if (shape === 'square' && squareConnectorMode === 'corner') {
        const dx=b.x-a.x, dy=b.y-a.y;
        let aCorner1, aCorner2, bCorner1, bCorner2;
        if (Math.abs(dx) > Math.abs(dy)) {
          if (dx>0) {
            aCorner1 = createVector(a.x + r, a.y - r);
            aCorner2 = createVector(a.x + r, a.y + r);
            bCorner1 = createVector(b.x - r, b.y - r);
            bCorner2 = createVector(b.x - r, b.y + r);
          } else {
            aCorner1 = createVector(a.x - r, a.y - r);
            aCorner2 = createVector(a.x - r, a.y + r);
            bCorner1 = createVector(b.x + r, b.y - r);
            bCorner2 = createVector(b.x + r, b.y + r);
          }
        } else {
          if (dy>0) {
            aCorner1 = createVector(a.x - r, a.y + r);
            aCorner2 = createVector(a.x + r, a.y + r);
            bCorner1 = createVector(b.x - r, b.y - r);
            bCorner2 = createVector(b.x + r, b.y - r);
          } else {
            aCorner1 = createVector(a.x - r, a.y - r);
            aCorner2 = createVector(a.x + r, a.y - r);
            bCorner1 = createVector(b.x - r, b.y + r);
            bCorner2 = createVector(b.x + r, b.y + r);
          }
        }
        if (Math.abs(dx)>0 && Math.abs(dy)>0 && Math.abs(Math.abs(dx)-Math.abs(dy))<10) {
          if (dx>0 && dy>0) {
            aCorner1 = createVector(a.x + r, a.y - r);
            aCorner2 = createVector(a.x - r, a.y + r);
            bCorner1 = createVector(b.x + r, b.y - r);
            bCorner2 = createVector(b.x - r, b.y + r);
          } else if (dx>0 && dy<0) {
            aCorner1 = createVector(a.x - r, a.y - r);
            aCorner2 = createVector(a.x + r, a.y + r);
            bCorner1 = createVector(b.x - r, b.y - r);
            bCorner2 = createVector(b.x + r, b.y + r);
          } else if (dx<0 && dy>0) {
            aCorner1 = createVector(a.x + r, a.y + r);
            aCorner2 = createVector(a.x - r, a.y - r);
            bCorner1 = createVector(b.x + r, b.y + r);
            bCorner2 = createVector(b.x - r, b.y + r);
          } else {
            aCorner1 = createVector(a.x - r, a.y + r);
            aCorner2 = createVector(a.x + r, a.y - r);
            bCorner1 = createVector(b.x - r, b.y + r);
            bCorner2 = createVector(b.x + r, b.y - r);
          }
        }
        gfx.beginShape();
        gfx.vertex(aCorner1.x, aCorner1.y); gfx.vertex(bCorner1.x, bCorner1.y);
        gfx.vertex(bCorner2.x, bCorner2.y); gfx.vertex(aCorner2.x, aCorner2.y);
        gfx.endShape(CLOSE);
      } else {
        const dir = p5.Vector.sub(b,a).normalize();
        const perp = createVector(-dir.y, dir.x).mult(r);
        const a1 = p5.Vector.add(a, perp);
        const a2 = p5.Vector.sub(a, perp);
        const b1 = p5.Vector.add(b, perp);
        const b2 = p5.Vector.sub(b, perp);
        gfx.beginShape();
        gfx.vertex(a1.x,a1.y); gfx.vertex(b1.x,b1.y);
        gfx.vertex(b2.x,b2.y); gfx.vertex(a2.x,a2.y);
        gfx.endShape(CLOSE);
      }
    }

    // ---------------------------
    // Grid
    // ---------------------------
    function rebuildGrid() {
      grid = [];
      for (let i=0;i<cols;i++) {
        grid[i] = [];
        for (let j=0;j<rows;j++) {
          grid[i][j] = createVector(margin + i*spacing, margin + j*spacing);
        }
      }
    }

    // FIX: remap strokes by grid index (prevents drift when spacing/margin change)
    function updateValues() {
      const oldCols = cols, oldRows = rows, oldSpacing = spacing, oldMargin = margin;
      // Snapshot "old grid" (only logical; we don't need to store coords explicitly)
      // Read new values
      radius = parseInt(document.getElementById("radius").value);
      spacing = parseInt(document.getElementById("spacing").value);
      margin  = parseInt(document.getElementById("margin").value);
      cols    = parseInt(document.getElementById("cols").value);
      rows    = parseInt(document.getElementById("rows").value);

      // Build new grid coordinates
      const newGrid = [];
      for (let i=0;i<cols;i++) {
        newGrid[i] = [];
        for (let j=0;j<rows;j++) {
          newGrid[i][j] = createVector(margin + i*spacing, margin + j*spacing);
        }
      }

      const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
      function snapToIndex(pt, gridCols, gridRows, gMargin, gSpacing) {
        let i = Math.round((pt.x - gMargin) / gSpacing);
        let j = Math.round((pt.y - gMargin) / gSpacing);
        i = clamp(i, 0, gridCols-1);
        j = clamp(j, 0, gridRows-1);
        return {i, j};
      }
      function remapStroke(strokeArr) {
        for (let k=0;k<strokeArr.length;k++) {
          const p = strokeArr[k];
          const idx = snapToIndex(p, oldCols, oldRows, oldMargin, oldSpacing);
          const ni = clamp(idx.i, 0, cols-1);
          const nj = clamp(idx.j, 0, rows-1);
          const np = newGrid[ni][nj];
          p.x = np.x; p.y = np.y;
        }
      }
      // Remap all stored data
      for (const s of strokes) remapStroke(s);
      remapStroke(currentStroke);
      for (const entry of undoStack) { if (entry && entry.stroke) remapStroke(entry.stroke); }

      // Commit grid
      grid = newGrid;
    }

    // ---------------------------
    // Game of Life
    // ---------------------------
    function initGameOfLife() {
      gameOfLifeGrid = [];
      for (let i=0;i<cols;i++) {
        gameOfLifeGrid[i] = [];
        for (let j=0;j<rows;j++) gameOfLifeGrid[i][j] = false;
      }
      for (const stroke of strokes) {
        for (const point of stroke) {
          const gridPos = findGridPosition(point);
          if (gridPos) gameOfLifeGrid[gridPos.i][gridPos.j] = true;
        }
      }
    }
    function findGridPosition(point) {
      for (let i=0;i<cols;i++) for (let j=0;j<rows;j++) {
        if (dist(point.x, point.y, grid[i][j].x, grid[i][j].y) < radius) return {i,j};
      }
      return null;
    }
    function updateGameOfLife() {
      const newGrid = [];
      for (let i=0;i<cols;i++) {
        newGrid[i] = [];
        for (let j=0;j<rows;j++) {
          const neighbors = countNeighbors(i,j);
          const cur = gameOfLifeGrid[i][j];
          if (cur && (neighbors===2 || neighbors===3)) newGrid[i][j] = true;
          else if (!cur && neighbors===3) newGrid[i][j] = true;
          else newGrid[i][j] = false;
        }
      }
      gameOfLifeGrid = newGrid;
    }
    function countNeighbors(x,y) {
      let c=0;
      for (let i=-1;i<=1;i++) for (let j=-1;j<=1;j++) {
        if (i===0 && j===0) continue;
        let col = x+i, row = y+j;
        if (col<0) col=cols-1; if (col>=cols) col=0;
        if (row<0) row=rows-1; if (row>=rows) row=0;
        if (gameOfLifeGrid[col] && gameOfLifeGrid[col][row]) c++;
      }
      return c;
    }

    // ---------------------------
    // Mouse
    // ---------------------------
    window.mousePressed = function() {
      if (mouseX < width && mouseY < height) {
        if (gameOfLifeMode) {
          const pos = nearestGridIndex(mouseX, mouseY);
          if (pos) gameOfLifeGrid[pos.i][pos.j] = !gameOfLifeGrid[pos.i][pos.j];
        } else if (warpMode) {
          const pt = findClosestNode(mouseX, mouseY);
          if (pt) {
            if (!warpStartPoint) warpStartPoint = pt.copy();
            else {
              if (!pt.equals(warpStartPoint)) {
                const warpStroke = [warpStartPoint.copy(), pt.copy()];
                const col = useColors ? color(random(30,220), random(30,220), random(30,220)) : color(0);
                undoStack.push({ stroke: warpStroke, color: col, shape: brushShape });
                applyUndoStack();
              }
              warpStartPoint = null;
            }
          }
        } else {
          currentStroke = [];
        }
      }
    };
    window.mouseDragged = function() {
      if (mouseX < width && mouseY < height) {
        if (gameOfLifeMode) {
          const pos = nearestGridIndex(mouseX, mouseY);
          if (pos) gameOfLifeGrid[pos.i][pos.j] = true;
        } else if (!warpMode) {
          const pt = findClosestNode(mouseX, mouseY);
          if (pt && !pointInStroke(pt, currentStroke)) currentStroke.push(pt.copy());
        }
      }
    };
    window.mouseReleased = function() {
      if (currentStroke.length>0 && !warpMode) {
        undoStack.push({
          stroke: currentStroke.map(p=>p.copy()),
          color: useColors ? color(random(30,220), random(30,220), random(30,220)) : color(0),
          shape: brushShape
        });
        applyUndoStack();
        currentStroke = [];
      }
    };
    function nearestGridIndex(x,y) {
      for (let i=0;i<cols;i++) for (let j=0;j<rows;j++) {
        const node = grid[i][j];
        if (dist(x,y,node.x,node.y) < radius) return {i,j};
      }
      return null;
    }
    function findClosestNode(x,y) {
      for (let i=0;i<cols;i++) for (let j=0;j<rows;j++) {
        const node = grid[i][j];
        if (dist(x,y,node.x,node.y) < radius*1.2) return node.copy();
      }
      return null;
    }
    function pointInStroke(p, stroke) { return stroke.some(pt => p.equals(pt)); }
    function applyUndoStack() {
      strokes = undoStack.map(e=>e.stroke);
      strokeColors = undoStack.map(e=>e.color);
      strokeShapes = undoStack.map(e=>e.shape || 'circle');
    }

    // ---------------------------
    // UI events
    // ---------------------------
    function setupParamUpdates() {
      const params = ['radius','spacing','margin','cols','rows'];
      params.forEach(param => {
        const slider = document.getElementById(param);
        const display = document.getElementById(param + '-val');
        slider.addEventListener('input', () => {
          display.textContent = slider.value;
          updateValues();
        });
      });
    }
    function setupShapeButtons() {
      document.querySelectorAll('.shape-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          brushShape = btn.dataset.shape;
          document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          const row = document.getElementById('square-connector-row');
          row.style.display = (brushShape === 'square') ? 'flex' : 'none';
        });
      });
      document.getElementById('corner-connect').addEventListener('change', (e)=>{
        squareConnectorMode = e.target.checked ? 'corner' : 'center';
      });
    }

    const presetConfigs = {
        "3x3":   { radius: 65, spacing: 140, margin: 100, cols: 3, rows: 3 },
        "4x4":   { radius: 65, spacing: 140,  margin: 100, cols: 4, rows: 4 },
        "5x5":   { radius: 65, spacing: 140,  margin: 100, cols: 5, rows: 5 },
        "6x6":   { radius: 56, spacing: 120,  margin: 100, cols: 6, rows: 6 },
        "10x10": { radius: 35, spacing: 75,  margin: 100, cols: 10, rows: 10 }
      };
    document.querySelectorAll(".preset-btn").forEach(btn => {
      btn.addEventListener("click", () => {
        const preset = btn.dataset.preset;
        const cfg = presetConfigs[preset]; if (!cfg) return;
        document.getElementById("radius").value = cfg.radius;
        document.getElementById("spacing").value = cfg.spacing;
        document.getElementById("margin").value  = cfg.margin;
        document.getElementById("cols").value    = cfg.cols;
        document.getElementById("rows").value    = cfg.rows;
        document.getElementById("radius-val").textContent  = cfg.radius;
        document.getElementById("spacing-val").textContent = cfg.spacing;
        document.getElementById("margin-val").textContent  = cfg.margin;
        document.getElementById("cols-val").textContent    = cfg.cols;
        document.getElementById("rows-val").textContent    = cfg.rows;
        updateValues();
        document.querySelectorAll(".preset-btn").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
      });
    });

    document.getElementById("clear").addEventListener("click", () => {
      strokes = []; strokeColors = []; strokeShapes = []; currentStroke = []; undoStack = []; warpStartPoint = null;
    });
    document.getElementById("toggleColor").addEventListener("click", (e) => {
      useColors = !useColors; e.target.classList.toggle('active', useColors);
    });
    document.getElementById("toggleOutline").addEventListener("click", (e) => {
      outlineOnly = !outlineOnly; e.target.classList.toggle('active', outlineOnly);
    });
    document.getElementById("toggleGrid").addEventListener("click", (e) => {
      showGrid = !showGrid; e.target.classList.toggle('active', showGrid);
    });
    document.getElementById("toggleWarp").addEventListener("click", (e) => {
      warpMode = !warpMode; e.target.classList.toggle('active', warpMode);
      warpStartPoint = null; currentStroke = [];
    });
    document.getElementById("undo").addEventListener("click", () => {
      if (undoStack.length>0) { undoStack.pop(); applyUndoStack(); }
    });

    // ---------------------------
    // Export — PNG & SVG
    // ---------------------------
    function computeBounds() {
      // Include brush radius so shapes/connectors and line stroke width don't get clipped
      let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
      const pts = strokes.flat();
      if (pts.length === 0) return null;
      for (const p of pts) {
        minX = Math.min(minX, p.x - radius);
        maxX = Math.max(maxX, p.x + radius);
        minY = Math.min(minY, p.y - radius);
        maxY = Math.max(maxY, p.y + radius);
      }
      return { minX, minY, maxX, maxY, w: maxX-minX, h: maxY-minY };
    }
    function renderToGraphics(pg, size, asLines) {
      const b = computeBounds();
      if (typeof pg.clear === 'function') {
        pg.clear();
      }
      pg.background(255);
      if (!b) return;
      // pad to avoid touching edges and AA cropping
      const pad = 2;
      const sx = (size - pad*2) / Math.max(b.w, 1);
      const sy = (size - pad*2) / Math.max(b.h, 1);
      const s  = Math.min(sx, sy);
      const offsetX = (size - b.w * s)/2 - b.minX*s;
      const offsetY = (size - b.h * s)/2 - b.minY*s;

      pg.push();
      pg.translate(offsetX, offsetY);

      for (let i=0;i<strokes.length;i++) {
        const strokePath = strokes[i];
        const col = useColors ? strokeColors[i] : color(0);
        if (asLines) {
          pg.noFill(); pg.stroke(col); pg.strokeWeight(radius*2*s);
          for (let j=0;j<strokePath.length-1;j++) {
            const a=strokePath[j], b=strokePath[j+1];
            pg.line(a.x*s, a.y*s, b.x*s, b.y*s);
          }
        } else {
          // Filled shapes + connectors
          const shape = strokeShapes[i] || 'circle';
          // We'll draw by reusing helpers with scaled coords
          // Set style per shape segment within helpers
          for (let j=0;j<strokePath.length;j++) {
            const px = strokePath[j].x*s;
            const py = strokePath[j].y*s;
            if (outlineOnly) { pg.stroke(col); pg.strokeWeight(1); pg.noFill(); }
            else { pg.fill(col); pg.noStroke(); }
            drawShapeOn(pg, px, py, radius*s, shape);
            if (j>0) {
              const a = createVector(strokePath[j-1].x*s, strokePath[j-1].y*s);
              const b = createVector(px, py);
              if (shape==='circle') drawCapsuleOn(pg, a, b, radius*s);
              else drawConnectorOn(pg, a, b, radius*s, shape);
            }
          }
        }
      }
      pg.pop();
    }

    function downloadBlob(filename, blob) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // Fallback SVG builder when p5.svg is unavailable
    function buildSVGFallback(size, asLines) {
      const b = computeBounds();
      const serializerHeader = '<?xml version="1.0" encoding="UTF-8"?>\n';
      if (!b) {
        return serializerHeader + `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}"></svg>`;
      }
      const pad = 1;
      const sx = (size - pad*2) / Math.max(b.w, 1);
      const sy = (size - pad*2) / Math.max(b.h, 1);
      const s = Math.min(sx, sy);
      const offsetX = (size - b.w * s)/2 - b.minX*s;
      const offsetY = (size - b.h * s)/2 - b.minY*s;

      let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">\n`;
      svg += `<g transform="translate(${offsetX},${offsetY}) scale(${s})">\n`;
      for (let i = 0; i < strokes.length; i++) {
        const strokePath = strokes[i];
        const col = useColors ? strokeColors[i] : color(0);
        const hex = col.toString('#rrggbb');
        const shape = strokeShapes[i] || 'circle';
        if (asLines) {
          svg += `<g stroke="${hex}" fill="none" stroke-width="${radius * 2}">\n`;
          for (let j = 0; j < strokePath.length - 1; j++) {
            const a = strokePath[j], bpt = strokePath[j + 1];
            svg += `<line x1="${a.x}" y1="${a.y}" x2="${bpt.x}" y2="${bpt.y}" />\n`;
          }
          svg += `</g>\n`;
        } else {
          svg += `<g fill="${hex}" stroke="none">\n`;
          for (let j = 0; j < strokePath.length; j++) {
            const p = strokePath[j];
            if (shape === 'square') {
              svg += `<rect x="${p.x - radius}" y="${p.y - radius}" width="${radius * 2}" height="${radius * 2}" />\n`;
            } else {
              svg += `<circle cx="${p.x}" cy="${p.y}" r="${radius}" />\n`;
            }
            if (j > 0) {
              const a = strokePath[j - 1], bpt = p;
              const dx = bpt.x - a.x, dy = bpt.y - a.y;
              if (shape === 'square' && squareConnectorMode === 'corner') {
                let aCorner1, aCorner2, bCorner1, bCorner2;
                if (Math.abs(dx) > Math.abs(dy)) {
                  if (dx > 0) {
                    aCorner1 = { x: a.x + radius, y: a.y - radius };
                    aCorner2 = { x: a.x + radius, y: a.y + radius };
                    bCorner1 = { x: bpt.x - radius, y: bpt.y - radius };
                    bCorner2 = { x: bpt.x - radius, y: bpt.y + radius };
                  } else {
                    aCorner1 = { x: a.x - radius, y: a.y - radius };
                    aCorner2 = { x: a.x - radius, y: a.y + radius };
                    bCorner1 = { x: bpt.x + radius, y: bpt.y - radius };
                    bCorner2 = { x: bpt.x + radius, y: bpt.y + radius };
                  }
                } else {
                  if (dy > 0) {
                    aCorner1 = { x: a.x - radius, y: a.y + radius };
                    aCorner2 = { x: a.x + radius, y: a.y + radius };
                    bCorner1 = { x: bpt.x - radius, y: bpt.y - radius };
                    bCorner2 = { x: bpt.x + radius, y: bpt.y - radius };
                  } else {
                    aCorner1 = { x: a.x - radius, y: a.y - radius };
                    aCorner2 = { x: a.x + radius, y: a.y - radius };
                    bCorner1 = { x: bpt.x - radius, y: bpt.y + radius };
                    bCorner2 = { x: bpt.x + radius, y: bpt.y + radius };
                  }
                }
                svg += `<path d="M ${aCorner1.x} ${aCorner1.y} L ${bCorner1.x} ${bCorner1.y} L ${bCorner2.x} ${bCorner2.y} L ${aCorner2.x} ${aCorner2.y} Z" />\n`;
              } else {
                const len = Math.max(1e-6, Math.sqrt(dx*dx + dy*dy));
                const nx = dx / len, ny = dy / len;
                const px = -ny, py = nx;
                const ax1 = a.x + px * radius;
                const ay1 = a.y + py * radius;
                const ax2 = a.x - px * radius;
                const ay2 = a.y - py * radius;
                const bx1 = bpt.x + px * radius;
                const by1 = bpt.y + py * radius;
                const bx2 = bpt.x - px * radius;
                const by2 = bpt.y - py * radius;
                svg += `<path d="M ${ax1} ${ay1} L ${bx1} ${by1} L ${bx2} ${by2} L ${ax2} ${ay2} Z" />\n`;
              }
            }
          }
          svg += `</g>\n`;
        }
      }
      svg += `</g>\n</svg>`;
      return serializerHeader + svg;
    }

    document.getElementById("export-png").addEventListener("click", () => {
      const size = parseInt(document.getElementById("export-size").value);
      const asLines = document.getElementById("mode-toggle")?.checked ?? false;
      const pg = createGraphics(size, size);
      renderToGraphics(pg, size, asLines);
      const dataURL = pg.elt.toDataURL("image/png");
      downloadBlob(`gr1d-${size}px.png`, (function(){const b = atob(dataURL.split(',')[1]); const len=b.length; const u8=new Uint8Array(len); for (let i=0;i<len;i++) u8[i]=b.charCodeAt(i); return new Blob([u8], {type:'image/png'});})());
    });

    document.getElementById("export-svg").addEventListener("click", () => {
      const size = parseInt(document.getElementById("export-size").value);
      const asLines = document.getElementById("mode-toggle")?.checked ?? false;
      if (typeof SVG !== 'undefined') {
        // Use p5.svg renderer when available
        const pg = createGraphics(size, size, SVG);
        renderToGraphics(pg, size, asLines);
        const svg = pg.elt; // <svg> element
        // Serialize
        const serializer = new XMLSerializer();
        let content = serializer.serializeToString(svg);
        if (!content.startsWith('<?xml')) {
          content = '<?xml version="1.0" encoding="UTF-8"?>\n' + content;
        }
        const blob = new Blob([content], {type: 'image/svg+xml;charset=utf-8'});
        downloadBlob(`gr1d-${size}px.svg`, blob);
      } else {
        // Fallback: build SVG string manually (no plugin)
        const content = buildSVGFallback(size, asLines);
        const blob = new Blob([content], {type: 'image/svg+xml;charset=utf-8'});
        downloadBlob(`gr1d-${size}px.svg`, blob);
      }
    });

    // ---------------------------
    // Surprise / Game of Life UI
    // ---------------------------
    document.getElementById("surprise").addEventListener("click", () => {
      strokes = []; strokeColors = []; strokeShapes=[]; undoStack = [];
      const totalStrokes = floor(random(3,8));
      for (let s=0;s<totalStrokes;s++) {
        const stroke=[]; const visited = new Set();
        let x=floor(random(cols)), y=floor(random(rows));
        let length=floor(random(4,10));
        for (let i=0;i<length;i++) {
          if (x<0||x>=cols||y<0||y>=rows) break;
          const key = `${x},${y}`; if (visited.has(key)) break;
          stroke.push(grid[x][y].copy()); visited.add(key);
          const directions=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,-1],[-1,1],[1,-1]];
          const [dx,dy] = random(directions);
          x+=dx; y+=dy;
        }
        if (stroke.length>1) {
          const col = useColors ? color(random(30,255), random(30,255), random(30,255)) : color(0);
          undoStack.push({ stroke: stroke.map(p=>p.copy()), color: col, shape: brushShape });
        }
      }
      applyUndoStack();
    });

    document.getElementById("toggleGameOfLife").addEventListener("click", (e) => {
      gameOfLifeMode = !gameOfLifeMode;
      e.target.classList.toggle('active', gameOfLifeMode);
      const ctrls = document.getElementById('game-of-life-controls');
      if (gameOfLifeMode) {
        ctrls.style.display = 'block';
        initGameOfLife();
        warpMode = false;
        document.getElementById('toggleWarp').classList.remove('active');
      } else {
        ctrls.style.display = 'none';
        gameOfLifeRunning = false;
        document.getElementById('gol-play').textContent = 'PLAY';
        document.getElementById('gol-play').style.background = '#4CAF50';
      }
    });
    document.getElementById('gol-play').addEventListener('click', (e) => {
      gameOfLifeRunning = !gameOfLifeRunning;
      if (gameOfLifeRunning) { e.target.textContent='PAUSE'; e.target.style.background='#f44336'; }
      else { e.target.textContent='PLAY'; e.target.style.background='#4CAF50'; }
    });
    document.getElementById('gol-step').addEventListener('click', () => updateGameOfLife());
    document.getElementById('gol-clear').addEventListener('click', () => {
      for (let i=0;i<cols;i++) for (let j=0;j<rows;j++) gameOfLifeGrid[i][j]=false;
      gameOfLifeRunning=false;
      document.getElementById('gol-play').textContent='PLAY';
      document.getElementById('gol-play').style.background='#4CAF50';
    });
    document.getElementById('gol-speed').addEventListener('input', (e)=>{
      gameOfLifeSpeed = parseInt(e.target.value);
      document.getElementById('gol-speed-val').textContent = e.target.value;
    });

    // ---------------------------
    // Shortcuts
    // ---------------------------
    document.addEventListener('keydown', (e) => {
      switch(e.key.toLowerCase()) {
        case 'g': document.getElementById('toggleGrid').click(); break;
        case 'c': document.getElementById('toggleColor').click(); break;
        case 'o': document.getElementById('toggleOutline').click(); break;
        case 'w': document.getElementById('toggleWarp').click(); break;
        case 's': document.getElementById('surprise').click(); break;
        case 'x': document.getElementById('clear').click(); break;
        case 'z': document.getElementById('undo').click(); break;
        case 'l': document.getElementById('toggleGameOfLife').click(); break;
        case '1': document.querySelector('[data-shape="circle"]').click(); break;
        case '2': document.querySelector('[data-shape="square"]').click(); break;
        case 'p': document.getElementById('export-png').click(); break;
        case 'v': document.getElementById('export-svg').click(); break;
      }
    });
  </script>
</body>
</html>
