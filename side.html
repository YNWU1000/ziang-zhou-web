<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Side Project — Cut‑Up Collage</title>
  <link rel="stylesheet" href="styles/styles.css">
</head>
<body>

<!-- Seed text (typed by basic.js), then we keep appending dynamically -->
<p id="source" aria-label="Cut-up collage">
  <span class="chunk">Index</span>.
  <br />
  <span class="chunk">Senseless & Decrypted.</span>
</p>

<p id="out" aria-live="polite" aria-atomic="true"></p>

<script defer src="js/basic.js"></script>
<script>
  // After the initial typing is done, continuously append scrambled-typed phrases
  document.addEventListener('app:paragraph-ready', (e) => {
    const p = e.detail && e.detail.p ? e.detail.p : document.getElementById('out');
    if (!p) return;

    // Lightweight local "LLM" token generator (cut-up style)
    const A = [
      'process', 'salt', 'midnight', 'buffer', 'chorus', 'syntax', 'mercury', 'dream', 'cache', 'window',
      'loop', 'clouds', 'debug', 'whisper', 'compile', 'handoff', 'paper', 'signal', 'echo', 'drift',
      'vector', 'hinge', 'model', 'mask', 'tunnel', 'orbit', 'node', 'kernel', 'honey', 'static'
    ];
    const B = [
      'breaks again', 'leaves a note', 'forgets the key', 'reboots', 'waits politely', 'changes tone',
      'asks the room', 'speaks in logs', 'draws a square', 'becomes vapor'
    ];
    const C = [
      '– sincerely', '(stage left)', '[checkpoint]', '{draft}', '/// todo', '… or does it?', '— probably', '– cut to black'
    ];

    function pick(arr){ return arr[(Math.random()*arr.length)|0]; }

    async function typeScramble(el, text) {
      const CHARS = '█▓▒░#%*+—=<>/\\[]{}()ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      const sleep = (ms) => new Promise(r => setTimeout(r, ms));
      for (const ch of text) {
        el.textContent += CHARS[(Math.random()*CHARS.length)|0];
        await sleep(5 + Math.random()*8);   // ~3x faster
        el.textContent = el.textContent.slice(0, -1) + ch;
        await sleep(3 + Math.random()*6);   // ~3x faster
      }
    }

    async function appendPhrase() {
      const span = document.createElement('span');
      span.className = 'chunk';
      p.appendChild(span);
      const phrase = `${pick(A)} ${pick(B)} ${pick(C)}`;
      await typeScramble(span, phrase);
      // random line breaks for jagged layout
      if (Math.random() < 0.5) p.appendChild(document.createElement('br'));
    }

    let running = true;
    async function loop() {
      // Stop when the text visually fills the viewport height (leave a bit of footer space)
      const rect = p.getBoundingClientRect();
      const limit = innerHeight - 80;
      if (rect.bottom >= limit) { running = false; return; }
      await appendPhrase();
      if (running) requestAnimationFrame(loop);
    }
    // kick off after a short pause so #out is present
    setTimeout(() => requestAnimationFrame(loop), 200);
  }, { once: true });
</script>

</body>
</html>
